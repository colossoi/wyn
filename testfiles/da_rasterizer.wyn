-- Original GLSL source code
--
-- #define LINEAR_ROTATION
--
-- #define WEIGHT (3.0 / iResolution.x)
-- const vec3 RED = vec3(1.0,0.0,0.0);
-- const vec3 GREEN = vec3(0.0,1.0,0.0);
-- const vec3 BLUE = vec3(0.0,0.8,1.0);
-- const vec3 WHITE = vec3(1.0,1.0,0.97);
-- const vec3 YELLOW = vec3(1.0,1.0,0.0);
--
-- // rasterize functions
-- float line(vec2 p, vec2 p0, vec2 p1, float w) {
--     vec2 d = p1 - p0;
--     float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);
--     vec2 proj = p0 + d * t;
--     float dist = length(p - proj);
--     dist = 1.0/dist*WEIGHT*w;
--     return min(dist*dist,1.0);
-- }
-- float circle(vec2 p, vec2 c, float r, float w) {
--     float dist = abs(length(p - c)) + r;
--     dist = 1.0/dist*WEIGHT*w;
--     return min(dist*dist,1.0);
-- }
--
-- // matrices
-- mat4 getRotMatrix(vec3 a) {
--     vec3 s = sin(a);
--     vec3 c = cos(a);
--     mat4 ret;
--     ret[0] = vec4(c.y*c.z,c.y*s.z,-s.y,0.0);
--     ret[1] = vec4(s.x*s.y*c.z-c.x*s.z,s.x*s.y*s.z+c.x*c.z,s.x*c.y,0.0);
--     ret[2] = vec4(c.x*s.y*c.z+s.x*s.z, c.x*s.y*s.z-s.x*c.z,   c.x*c.y,0.0);
--     ret[3] = vec4(0.0,0.0,0.0,1.0);
--     return ret;
-- }
-- mat4 getPosMatrix(vec3 p) {
--     mat4 ret;
--     ret[0] = vec4(1.0,0.0,0.0,p.x);
--     ret[1] = vec4(0.0,1.0,0.0,p.y);
--     ret[2] = vec4(0.0,0.0,1.0,p.z);
--     ret[3] = vec4(0.0,0.0,0.0,1.0);
--     return ret;
-- }
--
-- // utils
-- vec3 mix3(vec3 a, vec3 b, vec3 c, float t) {
--     if(t>0.5) return mix(b,c,t*2.0-1.0);
--     else return mix(a,b,t*2.0);
-- }
-- vec3 fragment(vec3 p) {
--     float t = sin(p.x*0.8+iTime*0.5)*0.5+0.5;
--     float fog = min(pow(p.z,3.0)*400.0,1.0);
--     return mix3(RED,GREEN,BLUE,t) * fog;
-- }
--
-- void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
-- 	vec2 uv = fragCoord.xy / iResolution.xy;
--     uv = uv * 2.0 - 1.0;
--     uv.x *= iResolution.x / iResolution.y;
--     //uv = uv * (1.0 + pow(length(uv)*0.4,0.5)) * 0.6;
--
--     float line_width = 0.4;
--     float time = iTime * 0.31415;
--     vec3 c = vec3(mix(vec3(0.19,0.13,0.1),vec3(1.0), 0.5*pow(length(uv)*0.5,2.0)));
--     mat4 cam = getPosMatrix(vec3(0.0,0.0,10.0));
--
-- #ifdef LINEAR_ROTATION
--     mat4 rot = getRotMatrix(vec3(time,time*0.86,time*0.473));
-- #else
--     float p = 0.08;
--     mat4 rot = getRotMatrix(vec3(time		+sin(time*30.0)*p,
--                                  time*0.860	+sin(time*20.0)*p*1.24,
--                                  time*0.473	+sin(time*10.0)*p));
-- #endif
--
--     vec3 instances[18];
--     instances[0] = vec3( 0.0, 0.0,-1.0);
--     instances[1] = vec3(-1.0, 0.0,-1.0);
--     instances[2] = vec3( 1.0, 0.0,-1.0);
--     instances[3] = vec3( 0.0, 1.0,-1.0);
--     instances[4] = vec3( 0.0,-1.0,-1.0);
--     instances[5] = vec3(-1.0, 0.0, 0.0);
--     instances[6] = vec3( 1.0, 0.0, 0.0);
--     instances[7] = vec3( 0.0, 1.0, 0.0);
--     instances[8] = vec3( 0.0,-1.0, 0.0);
--     instances[9] = vec3(-1.0,-1.0, 0.0);
--     instances[10] = vec3( 1.0, 1.0, 0.0);
--     instances[11] = vec3(-1.0, 1.0, 0.0);
--     instances[12] = vec3( 1.0,-1.0, 0.0);
--     instances[13] = vec3( 0.0, 0.0, 1.0);
--     instances[14] = vec3(-1.0, 0.0, 1.0);
--     instances[15] = vec3( 1.0, 0.0, 1.0);
--     instances[16] = vec3( 0.0, 1.0, 1.0);
--     instances[17] = vec3( 0.0,-1.0, 1.0);
--
--     // box pipeline
--     for(int dip = 0; dip < 18; dip++) {
--
--         // input assembly
--         vec3 vert[8];
--         vert[0] = vec3(-1.0,-1.0, 1.0);
--         vert[1] = vec3(-1.0, 1.0, 1.0);
--         vert[2] = vec3( 1.0, 1.0, 1.0);
--         vert[3] = vec3( 1.0,-1.0, 1.0);
--         vert[4] = vec3(-1.0,-1.0,-1.0);
--         vert[5] = vec3(-1.0, 1.0,-1.0);
--         vert[6] = vec3( 1.0, 1.0,-1.0);
--         vert[7] = vec3( 1.0,-1.0,-1.0);
--
--         // vertex processing
--         mat4 pos = getPosMatrix(instances[dip] * 4.0);
--         mat4 mat = pos * rot * cam;
--
--         for(int i = 0; i < 8; i++) {
--
--             // transform
--             vert[i] = (vec4(vert[i],1.0) * mat).xyz;
--
--             // perspective
--             vert[i].z = 1.0 / vert[i].z;
--             vert[i].xy *= vert[i].z;
--         }
--
--         // primitive assembly and rasterize
--         float i;
--         i  = line(uv,vert[0].xy,vert[1].xy,line_width);
--         i += line(uv,vert[1].xy,vert[2].xy,line_width);
--         i += line(uv,vert[2].xy,vert[3].xy,line_width);
--         i += line(uv,vert[3].xy,vert[0].xy,line_width);
--         i += line(uv,vert[4].xy,vert[5].xy,line_width);
--         i += line(uv,vert[5].xy,vert[6].xy,line_width);
--         i += line(uv,vert[6].xy,vert[7].xy,line_width);
--         i += line(uv,vert[7].xy,vert[4].xy,line_width);
--         i += line(uv,vert[0].xy,vert[4].xy,line_width);
--         i += line(uv,vert[1].xy,vert[5].xy,line_width);
--         i += line(uv,vert[2].xy,vert[6].xy,line_width);
--         i += line(uv,vert[3].xy,vert[7].xy,line_width);
--         c += fragment(vert[0]) * min(i,1.0);
--     }
--
--     instances[0] = vec3(-1.0, 1.0,-1.0);
--     instances[1] = vec3( 1.0, 1.0,-1.0);
--     instances[2] = vec3(-1.0,-1.0,-1.0);
--     instances[3] = vec3( 1.0,-1.0,-1.0);
--     instances[4] = vec3(-1.0, 1.0, 1.0);
--     instances[5] = vec3( 1.0, 1.0, 1.0);
--     instances[6] = vec3(-1.0,-1.0, 1.0);
--     instances[7] = vec3( 1.0,-1.0, 1.0);
--
--     // cicle pipeline
--     for(int dip = 0; dip < 8; dip++) {
--
--         // input assembly
--         vec3 vert = vec3(0.0);
--
--         // vertex processing
--         mat4 pos = getPosMatrix(instances[dip] * 4.0);
--         mat4 mat = pos * rot * cam;
--
--         // transform
--         vert = (vec4(vert,1.0) * mat).xyz;
--
--         // perspective
--         vert.z = 1.0 / vert.z;
--         vert.xy *= vert.z;
--
--         // rasterize
--         c += fragment(vert) * circle(uv,vert.xy,-vert.z,line_width);
--     }
--
--     // fragment
-- 	fragColor = vec4(c,1.0);
-- }



-- Uniforms from host
#[uniform(set=1, binding=0)] def iResolution: vec2f32
#[uniform(set=1, binding=1)] def iTime: f32

-- Vertex shader: full-screen triangle
def verts: [3]vec4f32 =
  [@[-1.0, -1.0, 0.0, 1.0],
   @[3.0, -1.0, 0.0, 1.0],
   @[-1.0, 3.0, 0.0, 1.0]]

#[vertex]
def vertex_main(#[builtin(vertex_index)] vertex_id:i32) -> #[builtin(position)] vec4f32 = verts[vertex_id]

-- Constants (using vector literals)
def red: vec3f32 = @[1.0, 0.0, 0.0]
def green: vec3f32 = @[0.0, 1.0, 0.0]
def blue: vec3f32 = @[0.0, 0.8, 1.0]
def white: vec3f32 = @[1.0, 1.0, 0.97]
def yellow: vec3f32 = @[1.0, 1.0, 0.0]

-- Matrix functions (inlined from graphics32)
def translation(p: vec3f32) -> mat4f32 =
  @[
    [1.0f32, 0.0f32, 0.0f32, p.x],
    [0.0f32, 1.0f32, 0.0f32, p.y],
    [0.0f32, 0.0f32, 1.0f32, p.z],
    [0.0f32, 0.0f32, 0.0f32, 1.0f32]
  ]

def rotation_euler(a: vec3f32) -> mat4f32 =
  let s = [f32.sin(a.x), f32.sin(a.y), f32.sin(a.z)] in
  let c = [f32.cos(a.x), f32.cos(a.y), f32.cos(a.z)] in
  @[
    [c[1]*c[2], c[1]*s[2], 0.0f32 - s[1], 0.0f32],
    [s[0]*s[1]*c[2] - c[0]*s[2], s[0]*s[1]*s[2] + c[0]*c[2], s[0]*c[1], 0.0f32],
    [c[0]*s[1]*c[2] + s[0]*s[2], c[0]*s[1]*s[2] - s[0]*c[2], c[0]*c[1], 0.0f32],
    [0.0f32, 0.0f32, 0.0f32, 1.0f32]
  ]

-- Helper functions
def clamp(x:f32, min:f32, max:f32) -> f32 =
  if x < min then min else if x > max then max else x

def mix3v(a:vec3f32, b:vec3f32, t:f32) -> vec3f32 =
  @[(a.x + (b.x - a.x) * t), (a.y + (b.y - a.y) * t), (a.z + (b.z - a.z) * t)]

-- Rasterize helpers
def line(weight:f32, p:vec2f32, p0:vec2f32, p1:vec2f32, w:f32) -> f32 =
  let d = @[(p1.x-p0.x), (p1.y-p0.y)] in
  let denom = dot(d, d) in
  let dp = @[(p.x-p0.x), (p.y-p0.y)] in
  let t_raw = if denom == 0.0 then 0.0 else (dot(d, dp) / denom) in
  let t = clamp(t_raw, 0.0, 1.0) in
  let proj = @[(p0.x + d.x*t), (p0.y + d.y*t)] in
  let pdiff = @[(p.x-proj.x), (p.y-proj.y)] in
  let dist = magnitude(pdiff) in
  let s = (if dist == 0.0 then 0.0 else (1.0 / dist)) * weight * w in
  f32.min(s*s, 1.0)

def circle(weight:f32, p:vec2f32, c:vec2f32, r:f32, w:f32) -> f32 =
  let diff = @[(p.x-c.x), (p.y-c.y)] in
  let dist = f32.abs(magnitude(diff)) + r in
  let s = (if dist == 0.0 then 0.0 else (1.0 / dist)) * weight * w in
  f32.min(s*s, 1.0)

def edge_line(verts: [8]vec3f32, weight: f32, uv: vec2f32, line_width: f32, e: [2]i32) -> f32 =
  let a = verts[e[0]] in
  let b = verts[e[1]] in
  line(weight, uv, @[a.x, a.y], @[b.x, b.y], line_width)

def sum_edges(verts: [8]vec3f32, weight: f32, uv: vec2f32, line_width: f32, edges: [12][2]i32) -> f32 =
  let (_, acc) = loop (i, acc) = (0, 0.0f32) while i < 12 do
    (i + 1, acc + edge_line(verts, weight, uv, line_width, edges[i]))
  in acc

-- utils
def mix3(a:vec3f32, b:vec3f32, c:vec3f32, t:f32) -> vec3f32 =
  if t > 0.5
  then mix3v(b, c, t*2.0 - 1.0)
  else mix3v(a, b, t*2.0)

def fragment(p:vec3f32, iTime:f32) -> vec3f32 =
  let t = f32.sin(p.x*0.8 + iTime*0.5)*0.5 + 0.5 in
  let fog = f32.min(p.z*p.z*p.z*400.0, 1.0) in
  let col = mix3(red, green, blue, t) in
  @[(col.x * fog), (col.y * fog), (col.z * fog)]

def cube_corners: [8]vec3f32 =
    [ @[-1.0, -1.0, 1.0],
      @[-1.0, 1.0, 1.0],
      @[1.0, 1.0, 1.0],
      @[1.0, -1.0, 1.0],
      @[-1.0, -1.0, -1.0],
      @[-1.0, 1.0, -1.0],
      @[1.0, 1.0, -1.0],
      @[1.0, -1.0, -1.0] ]

def instances_a: [18]vec3f32 =
  -- Instances (first batch, 18 boxes)
    [ @[0.0, 0.0, -1.0],
      @[-1.0, 0.0, -1.0],
      @[1.0, 0.0, -1.0],
      @[0.0, 1.0, -1.0],
      @[0.0, -1.0, -1.0],
      @[-1.0, 0.0, 0.0],
      @[1.0, 0.0, 0.0],
      @[0.0, 1.0, 0.0],
      @[0.0, -1.0, 0.0],
      @[-1.0, -1.0, 0.0],
      @[1.0, 1.0, 0.0],
      @[-1.0, 1.0, 0.0],
      @[1.0, -1.0, 0.0],
      @[0.0, 0.0, 1.0],
      @[-1.0, 0.0, 1.0],
      @[1.0, 0.0, 1.0],
      @[0.0, 1.0, 1.0],
      @[0.0, -1.0, 1.0] ]

def instances_b: [8]vec3f32 =
    -- Second instances (8 circles)
    [ @[-1.0, 1.0, -1.0],
      @[1.0, 1.0, -1.0],
      @[-1.0, -1.0, -1.0],
      @[1.0, -1.0, -1.0],
      @[-1.0, 1.0, 1.0],
      @[1.0, 1.0, 1.0],
      @[-1.0, -1.0, 1.0],
      @[1.0, -1.0, 1.0] ]

def edge_indexes: [12][2]i32 =
  -- Edge indices (loop invariant)
    [ [0,1],[1,2],[2,3],[3,0],
      [4,5],[5,6],[6,7],[7,4],
      [0,4],[1,5],[2,6],[3,7] ]

-- Main per-fragment function
-- Inputs:
--   iResolution : [w, h]
--   iTime       : time in seconds
--   fragCoord   : pixel coordinate [x, y]
-- Output: vec4f32 color
def main_image(iResolution:vec2f32, iTime:f32, fragCoord:vec2f32) -> vec4f32 =
  let weight = 3.0 / iResolution.x in

  -- Normalized, centered UV with aspect correction
  let uv0 : vec2f32 = @[(fragCoord.x / iResolution.x), (fragCoord.y / iResolution.y)] in
  let uv1 : vec2f32 = @[(uv0.x*2.0 - 1.0), (uv0.y*2.0 - 1.0)] in
  let uv  : vec2f32 = @[(uv1.x * (iResolution.x/iResolution.y)), uv1.y] in

  let line_width = 0.4 in
  let time = iTime * 0.31415 in

  let base_col = mix3v(@[0.19, 0.13, 0.10], @[1.0, 1.0, 1.0],
                         (0.5 * ((magnitude(uv) * 0.5) ** 2.0))) in
  let cam = translation(@[0.0, 0.0, 10.0]) in

  -- #define LINEAR_ROTATION
  let rot = rotation_euler(@[time, (time*0.86), (time*0.473)]) in

  -- Precompute rot * cam (loop invariant)
  -- Using row-vector convention (v * M), same as GLSL/DirectX
  let rot_cam : mat4f32 = mul(rot, cam) in


  -- Accumulate color
  let c_box_result =
    loop (idx, acc) = (0i32, base_col) while idx < 18 do
      let inst = instances_a[idx] in
      let pos  = translation(@[(inst.x * 4.0), (inst.y * 4.0), (inst.z * 4.0)]) in
      let mat  : mat4f32 = mul(pos, rot_cam) in

      -- Transform & perspective
      let v4s : [8]vec4f32 = map(|v:vec3f32| mul(@[v.x, v.y, v.z, 1.0], mat), cube_corners) in
      let verts1 : [8]vec3f32 =
        map(|q:vec4f32|
                  let zinv = 1.0 / q.z in
                  @[(q.x*zinv), (q.y*zinv), zinv],
               v4s) in

      let i_sum = sum_edges(verts1, weight, uv, line_width, edge_indexes) in

      let shade = fragment(verts1[0], iTime) in
      let intensity = f32.min(i_sum, 1.0) in
      let shade_scaled = @[(shade.x * intensity), (shade.y * intensity), (shade.z * intensity)] in
      let acc' = @[(acc.x + shade_scaled.x), (acc.y + shade_scaled.y), (acc.z + shade_scaled.z)] in
      (idx + 1, acc') in
  let (dummy1, c_box) = c_box_result in


  let c_final_result =
    loop (idx, acc) = (0i32, c_box) while idx < 8 do
      let inst = instances_b[idx] in
      let pos = translation(@[(inst.x * 4.0), (inst.y * 4.0), (inst.z * 4.0)]) in
      let mat : mat4f32 = mul(pos, rot_cam) in
      let v4  : vec4f32 = mul(@[0.0, 0.0, 0.0, 1.0], mat) in
      let zinv = 1.0 / v4.z in
      let vert : vec3f32 = @[(v4.x*zinv), (v4.y*zinv), zinv] in
      let sh  = fragment(vert, iTime) in
      let cov = circle(weight, uv, @[vert.x, vert.y], -vert.z, line_width) in
      let sh_scaled = @[(sh.x * cov), (sh.y * cov), (sh.z * cov)] in
      let acc' = @[(acc.x + sh_scaled.x), (acc.y + sh_scaled.y), (acc.z + sh_scaled.z)] in
      (idx + 1, acc') in
  let (dummy2, c_final) = c_final_result in

  @[c_final.x, c_final.y, c_final.z, 1.0]

-- Fragment shader entry point
#[fragment]
def fragment_main(#[builtin(frag_coord)] pos:vec4f32) -> #[location(0)] vec4f32 =
  let width = iResolution.x in
  let height = iResolution.y in
  let time = iTime in
  main_image(@[width, height], time, @[pos.x, pos.y])
