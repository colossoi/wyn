-- "Lava" by edankwan
-- Wyn port of the Shadertoy shader
-- Original: https://www.shadertoy.com/view/3sySRK

------------------------------------------------------------
-- Uniforms
------------------------------------------------------------
#[uniform(set=1, binding=0)] def iResolution: vec2f32
#[uniform(set=1, binding=1)] def iTime: f32

------------------------------------------------------------
-- Vertex shader: full-screen triangle
------------------------------------------------------------
def verts: [3]vec4f32 =
  [@[-1.0, -1.0, 0.0, 1.0],
   @[3.0, -1.0, 0.0, 1.0],
   @[-1.0, 3.0, 0.0, 1.0]]

#[vertex]
def vertex_main(#[builtin(vertex_index)] vertex_id: i32) -> #[builtin(position)] vec4f32 = verts[vertex_id]

------------------------------------------------------------
-- SDF helpers
------------------------------------------------------------

def opSmoothUnion(d1: f32, d2: f32, k: f32) -> f32 =
  let h = clamp((0.5 + 0.5 * (d2 - d1) / k), 0.0, 1.0) in
  mix(d2, d1, h) - k * h * (1.0 - h)

def sdSphere(p: vec3f32, s: f32) -> f32 =
  magnitude(p) - s

------------------------------------------------------------
-- Scene mapping
------------------------------------------------------------

def sdfScene(p: vec3f32) -> f32 =
  let (_, d) = loop (i, d) = (0, 2.0) while i < 16 do
    let fi = f32.i32(i) in
    let time = iTime * (fract((fi * 412.531 + 0.513)) - 0.5) * 2.0 in
    let offset = @[f32.sin((time + fi * 52.5126)) * 2.0,
                   f32.sin((time + fi * 64.62744)) * 2.0,
                   f32.sin((time + fi * 632.25)) * 0.8] in
    let sphere_p = @[p.x + offset.x, p.y + offset.y, p.z + offset.z] in
    let radius = mix(0.5, 1.0, fract((fi * 412.531 + 0.5124))) in
    let d2 = opSmoothUnion(sdSphere(sphere_p, radius), d, 0.4) in
    (i + 1, d2)
  in d

------------------------------------------------------------
-- Normal calculation (tetrahedron technique)
------------------------------------------------------------

def calcNormal(p: vec3f32) -> vec3f32 =
  let h = 1e-5 in
  let k = @[1.0, -1.0] in
  -- k.xyy, k.yyx, k.yxy, k.xxx
  let n1 = sdfScene(@[p.x + k.x * h, p.y + k.y * h, p.z + k.y * h]) in
  let n2 = sdfScene(@[p.x + k.y * h, p.y + k.y * h, p.z + k.x * h]) in
  let n3 = sdfScene(@[p.x + k.y * h, p.y + k.x * h, p.z + k.y * h]) in
  let n4 = sdfScene(@[p.x + k.x * h, p.y + k.x * h, p.z + k.x * h]) in
  normalize(@[k.x * n1 + k.y * n2 + k.y * n3 + k.x * n4,
              k.y * n1 + k.y * n2 + k.x * n3 + k.x * n4,
              k.y * n1 + k.x * n2 + k.y * n3 + k.x * n4])

------------------------------------------------------------
-- Ray marching
------------------------------------------------------------

def raymarch(rayOri: vec3f32, rayDir: vec3f32) -> (f32, vec3f32) =
  let (_, depth, p) = loop (i, depth, p) = (0, 0.0, rayOri) while i < 64 do
    let p2 = @[rayOri.x + rayDir.x * depth, rayOri.y + rayDir.y * depth, rayOri.z + rayDir.z * depth] in
    let dist = sdfScene(p2) in
    if dist < 1e-6 then (64, depth, p2)  -- break
    else (i + 1, depth + dist, p2)
  in (f32.min(6.0, depth), p)

------------------------------------------------------------
-- Fragment shader
------------------------------------------------------------

#[fragment]
def fragment_main(#[builtin(position)] fragCoord: vec4f32) -> #[location(0)] vec4f32 =
  -- Flip Y for Vulkan
  let coord = @[fragCoord.x, iResolution.y - fragCoord.y] in
  let uv = @[coord.x / iResolution.x, coord.y / iResolution.y] in

  -- Screen size is 6m x 6m
  let aspect = iResolution.x / iResolution.y in
  let rayOri = @[(uv.x - 0.5) * aspect * 6.0, (uv.y - 0.5) * 6.0, 3.0] in
  let rayDir = @[0.0, 0.0, -1.0] in

  let (depth, p) = raymarch(rayOri, rayDir) in

  let n = calcNormal(p) in
  let b = f32.max(0.0, dot(n, @[0.577, 0.577, 0.577])) in

  -- Colorful lava effect
  let phase = b + iTime * 3.0 in
  let col_r = (0.5 + 0.5 * f32.cos((phase + uv.x * 2.0 + 0.0))) * (0.85 + b * 0.35) in
  let col_g = (0.5 + 0.5 * f32.cos((phase + uv.y * 2.0 + 2.0))) * (0.85 + b * 0.35) in
  let col_b = (0.5 + 0.5 * f32.cos((phase + uv.x * 2.0 + 4.0))) * (0.85 + b * 0.35) in

  -- Depth fog
  let fog = f32.exp((0.0 - depth * 0.15)) in
  let alpha = 1.0 - (depth - 0.5) / 2.0 in

  @[col_r * fog, col_g * fog, col_b * fog, alpha]

------------------------------------------------------------
-- Original GLSL
------------------------------------------------------------

-- float opSmoothUnion( float d1, float d2, float k )
-- {
--     float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
--     return mix( d2, d1, h ) - k*h*(1.0-h);
-- }
-- 
-- float sdSphere( vec3 p, float s )
-- {
--   return length(p)-s;
-- } 
-- 
-- float map(vec3 p)
-- {
-- 	float d = 2.0;
-- 	for (int i = 0; i < 16; i++) {
-- 		float fi = float(i);
-- 		float time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;
-- 		d = opSmoothUnion(
--             sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),
-- 			d,
-- 			0.4
-- 		);
-- 	}
-- 	return d;
-- }
-- 
-- vec3 calcNormal( in vec3 p )
-- {
--     const float h = 1e-5; // or some other value
--     const vec2 k = vec2(1,-1);
--     return normalize( k.xyy*map( p + k.xyy*h ) + 
--                       k.yyx*map( p + k.yyx*h ) + 
--                       k.yxy*map( p + k.yxy*h ) + 
--                       k.xxx*map( p + k.xxx*h ) );
-- }
-- 
-- void mainImage( out vec4 fragColor, in vec2 fragCoord )
-- {
--     vec2 uv = fragCoord/iResolution.xy;
--     
--     // screen size is 6m x 6m
-- 	vec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);
-- 	vec3 rayDir = vec3(0.0, 0.0, -1.0);
-- 	
-- 	float depth = 0.0;
-- 	vec3 p;
-- 	
-- 	for(int i = 0; i < 64; i++) {
-- 		p = rayOri + rayDir * depth;
-- 		float dist = map(p);
--         depth += dist;
-- 		if (dist < 1e-6) {
-- 			break;
-- 		}
-- 	}
-- 	
--     depth = min(6.0, depth);
-- 	vec3 n = calcNormal(p);
--     float b = max(0.0, dot(n, vec3(0.577)));
--     vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);
--     col *= exp( -depth * 0.15 );
-- 	
--     // maximum thickness is 2m in alpha channel
--     fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);
-- }
-- 
-- /** SHADERDATA
-- {
-- 	"title": "My Shader 0",
-- 	"description": "Lorem ipsum dolor",
-- 	"model": "person"
-- }
-- */
