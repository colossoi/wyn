-- Simulated annealing "brick wall packing" demo in Wyn
-- Port of Futhark wall_anneal.fut
--
-- Each compute thread runs one annealing chain.
-- Results are written to storage buffers for visualization.

------------------------------------------------------------
-- Constants
------------------------------------------------------------
def WALL_WIDTH: i32 = 20
def NUM_BRICKS: i32 = 8
def NUM_STEPS: i32 = 1000

------------------------------------------------------------
-- Brick dimensions (fixed for demo)
------------------------------------------------------------
def bricks_w: [8]i32 = [3, 4, 2, 5, 3, 4, 2, 3]
def bricks_h: [8]i32 = [2, 1, 3, 2, 1, 2, 2, 1]

------------------------------------------------------------
-- Output storage buffers
-- Each chain writes its results at offset chain_id * stride
------------------------------------------------------------
#[storage(binding=1)] def out_costs: [64]i32
#[storage(binding=2)] def out_xs: [512]i32
#[storage(binding=3)] def out_ys: [512]i32
#[storage(binding=4)] def out_oris: [512]i32

------------------------------------------------------------
-- Utility functions
------------------------------------------------------------

def clamp_i32(x: i32, lo: i32, hi: i32) -> i32 =
  if x < lo then lo else if x > hi then hi else x

def imax(a: i32, b: i32) -> i32 =
  if a > b then a else b


------------------------------------------------------------
-- Profile operations (height profile of wall)
------------------------------------------------------------

-- Get max height in a range of the profile
def profile_max_range(profile: [20]i32, start: i32, width: i32) -> i32 =
  let (_, max_h) = loop (i, acc) = (0, 0) while i < width do
    let idx = start + i in
    let h = if idx >= 0 then if idx < 20 then profile[idx] else 0 else 0 in
    (i + 1, imax(acc, h))
  in max_h

-- Update profile in a range to a new height
def profile_update_range(profile: [20]i32, start: i32, width: i32, new_h: i32) -> [20]i32 =
  loop prof = profile for dx < width do
    let idx = start + dx in
    if idx >= 0 then if idx < 20 then _w_array_with(prof, idx, new_h) else prof else prof

------------------------------------------------------------
-- Layout computation
-- Place all bricks and compute the total empty space (cost)
------------------------------------------------------------

def compute_layout(xs: [8]i32, oris: [8]i32) -> (i32, [8]i32) =
  -- oris[i] = 0 means (w, h), oris[i] = 1 means (h, w)
  let init_profile: [20]i32 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] in
  let init_ys: [8]i32 = [0, 0, 0, 0, 0, 0, 0, 0] in

  let (final_profile, brick_area, ys) =
    loop (profile, area, ys) = (init_profile, 0, init_ys) for i < NUM_BRICKS do
      let w_base = bricks_w[i] in
      let h_base = bricks_h[i] in

      -- Orientation: 0 -> (w_base, h_base), 1 -> (h_base, w_base)
      let (w0, h0) = if oris[i] == 1 then (h_base, w_base) else (w_base, h_base) in

      -- Clamp x position
      let max_x_start = WALL_WIDTH - w0 in
      let x0 = clamp_i32(xs[i], 0, max_x_start) in

      -- Find height where brick sits
      let y0 = profile_max_range(profile, x0, w0) in
      let new_height = y0 + h0 in

      -- Update profile
      let profile2 = profile_update_range(profile, x0, w0, new_height) in

      -- Update area and ys
      let area2 = area + w0 * h0 in
      let ys2 = _w_array_with(ys, i, y0) in

      (profile2, area2, ys2)
  in

  -- Compute final cost (empty space)
  let h = profile_max_range(final_profile, 0, WALL_WIDTH) in
  let wall_area = WALL_WIDTH * h in
  let empty_area = wall_area - brick_area in

  (empty_area, ys)

-- Cost-only wrapper
def cost_for_layout(xs: [8]i32, oris: [8]i32) -> i32 =
  let (cost, _) = compute_layout(xs, oris) in cost

------------------------------------------------------------
-- One annealing step
------------------------------------------------------------

def anneal_step(
    rng: rand.state,
    xs: [8]i32,
    oris: [8]i32,
    cost: i32,
    temp: f32
  ) -> (rand.state, [8]i32, [8]i32, i32) =

  -- Pick random brick
  let (rng2, idx) = rand.int(rng, NUM_BRICKS) in

  -- Decide mutation type: flip orientation or move x
  let (rng3, rmove) = rand.next(rng2) in

  let (rng4, xs_new, oris_new) =
    if rmove < 0.5f32 then
      -- Flip orientation
      let ori_i = if oris[idx] == 0 then 1 else 0 in
      let oris2 = _w_array_with(oris, idx, ori_i) in
      (rng3, xs, oris2)
    else
      -- Move x position
      let (rng5, newx) = rand.int(rng3, WALL_WIDTH) in
      let xs2 = _w_array_with(xs, idx, newx) in
      (rng5, xs2, oris)
  in

  -- Compute new cost
  let cost_new = cost_for_layout(xs_new, oris_new) in
  let dE = f32.i32((cost_new - cost)) in

  -- Accept or reject
  let (rng5, r_accept) = rand.next(rng4) in
  let accept = if dE <= 0.0f32 then true
               else r_accept < f32.exp((0.0f32 - dE / temp)) in

  if accept then (rng5, xs_new, oris_new, cost_new)
  else (rng5, xs, oris, cost)

------------------------------------------------------------
-- Run full annealing chain
------------------------------------------------------------

def run_chain(seed: f32) -> (i32, [8]i32, [8]i32, [8]i32) =
  -- Initialize random x positions
  let init_xs: [8]i32 = [0, 0, 0, 0, 0, 0, 0, 0] in
  let init_oris: [8]i32 = [0, 0, 0, 0, 0, 0, 0, 0] in

  let (rng0, xs0) = loop (rng, xs) = (rand.init(seed), init_xs) for i < NUM_BRICKS do
    let (rng2, x_i) = rand.int(rng, WALL_WIDTH) in
    let xs2 = _w_array_with(xs, i, x_i) in
    (rng2, xs2)
  in

  -- Initialize random orientations
  let (rng1, oris0) = loop (rng, oris) = (rng0, init_oris) for i < NUM_BRICKS do
    let (rng2, r) = rand.next(rng) in
    let ori = if r < 0.5f32 then 0 else 1 in
    let oris2 = _w_array_with(oris, i, ori) in
    (rng2, oris2)
  in

  -- Compute initial cost
  let cost0 = cost_for_layout(xs0, oris0) in

  -- Temperature schedule
  let t0 = 100.0f32 in
  let tend = 0.1f32 in
  let steps_f = f32.i32(NUM_STEPS) in
  let log_ratio = f32.log((tend / t0)) in

  -- Run annealing loop, tracking best solution
  let (_, _, _, _, best_xs, best_oris, best_cost) =
    loop (rng, xs, oris, cost, best_xs, best_oris, best_cost) =
         (rng1, xs0, oris0, cost0, xs0, oris0, cost0)
    for step < NUM_STEPS do
      let step_f = f32.i32(step) in
      let t_frac = step_f / steps_f in
      let t_temp = t0 * f32.exp((t_frac * log_ratio)) in

      let (rng2, xs2, oris2, cost2) = anneal_step(rng, xs, oris, cost, t_temp) in

      let (best_xs2, best_oris2, best_cost2) =
        if cost2 < best_cost then (xs2, oris2, cost2)
        else (best_xs, best_oris, best_cost)
      in
      (rng2, xs2, oris2, cost2, best_xs2, best_oris2, best_cost2)
  in

  -- Compute final ys for best solution
  let (_, best_ys) = compute_layout(best_xs, best_oris) in

  (best_cost, best_xs, best_ys, best_oris)

------------------------------------------------------------
-- Write results to storage buffers
------------------------------------------------------------

def write_results(chain_id: i32, cost: i32, xs: [8]i32, ys: [8]i32, oris: [8]i32) -> () =
  -- Write cost
  let out_costs = out_costs with [chain_id] = cost in

  -- Write xs, ys, oris using accumulator pattern (8 values each, stride = chain_id * 8)
  let base = chain_id * 8 in
  let (out_xs, out_ys, out_oris) =
    loop (ox, oy, oo) = (out_xs, out_ys, out_oris) for i < 8 do
      let j = base + i in
      let ox = ox with [j] = xs[i] in
      let oy = oy with [j] = ys[i] in
      let oo = oo with [j] = oris[i] in
      (ox, oy, oo)
  in ()

------------------------------------------------------------
-- Compute shader entry point
-- Each thread runs one independent annealing chain
------------------------------------------------------------

#[compute(64, 1, 1)]
def compute_main(#[builtin(global_invocation_id)] gid: vec3u32) -> () =
  let chain_id = i32.u32(gid.x) in
  let num_chains = 64 in
  let seed = (f32.i32((chain_id + 1))) / (f32.i32((num_chains + 1))) in

  let (cost, xs, ys, oris) = run_chain(seed) in

  write_results(chain_id, cost, xs, ys, oris)
