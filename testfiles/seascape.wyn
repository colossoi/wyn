-- "Seascape" by Alexander Alekseev aka TDM - 2014
-- Wyn port of the Shadertoy classic
-- License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
-- Original: https://www.shadertoy.com/view/Ms2SD1

------------------------------------------------------------
-- Uniforms
------------------------------------------------------------
#[uniform(set=1, binding=0)] def iResolution: vec2f32
#[uniform(set=1, binding=1)] def iTime: f32
#[uniform(set=1, binding=5)] def iMouse: vec4f32

------------------------------------------------------------
-- Constants
------------------------------------------------------------
def NUM_STEPS: i32 = 32
def PI: f32 = 3.141592
def EPSILON: f32 = 0.001

def ITER_GEOMETRY: i32 = 3
def ITER_FRAGMENT: i32 = 5
def SEA_HEIGHT: f32 = 0.6
def SEA_CHOPPY: f32 = 4.0
def SEA_SPEED: f32 = 0.8
def SEA_FREQ: f32 = 0.16
def SEA_BASE: vec3f32 = @[0.0, 0.09, 0.18]
def SEA_WATER_COLOR: vec3f32 = @[0.48, 0.54, 0.36]  -- vec3(0.8,0.9,0.6)*0.6

def sea_time(t: f32) -> f32 = 1.0 + t * SEA_SPEED

-- octave_m = mat2(1.6, 1.2, -1.2, 1.6) - used for rotating UV in octaves
def octave_m: mat2f32 = @[[1.6, -1.2], [1.2, 1.6]]

------------------------------------------------------------
-- Vertex shader: full-screen triangle
------------------------------------------------------------
def verts: [3]vec4f32 =
  [@[-1.0, -1.0, 0.0, 1.0],
   @[3.0, -1.0, 0.0, 1.0],
   @[-1.0, 3.0, 0.0, 1.0]]

#[vertex]
def vertex_main(#[builtin(vertex_index)] vertex_id: i32) -> #[builtin(position)] vec4f32 = verts[vertex_id]

------------------------------------------------------------
-- Math helpers
------------------------------------------------------------

-- Hash function for noise
def hash(p: vec2f32) -> f32 =
  let h = dot(p, @[127.1, 311.7]) in
  fract(f32.sin(h) * 43758.5453123)

-- 2D noise
def noise(p: vec2f32) -> f32 =
  let i = floor(p) in
  let f = fract(p) in
  let u = @[f.x * f.x * (3.0 - 2.0 * f.x), f.y * f.y * (3.0 - 2.0 * f.y)] in
  let h00 = hash(i) in
  let h10 = hash(@[i.x + 1.0, i.y]) in
  let h01 = hash(@[i.x, i.y + 1.0]) in
  let h11 = hash(@[i.x + 1.0, i.y + 1.0]) in
  let mix_x0 = mix(h00, h10, u.x) in
  let mix_x1 = mix(h01, h11, u.x) in
  -1.0 + 2.0 * mix(mix_x0, mix_x1, u.y)

-- Euler angles to rotation matrix
def fromEuler(ang: vec3f32) -> mat3f32 =
  let a1 = @[f32.sin(ang.x), f32.cos(ang.x)] in
  let a2 = @[f32.sin(ang.y), f32.cos(ang.y)] in
  let a3 = @[f32.sin(ang.z), f32.cos(ang.z)] in
  -- Row-major: m[row][col]
  @[[a1.y*a3.y + a1.x*a2.x*a3.x, a1.y*a2.x*a3.x + a3.y*a1.x, 0.0 - a2.y*a3.x],
    [0.0 - a2.y*a1.x, a1.y*a2.y, a2.x],
    [a3.y*a1.x*a2.x + a1.y*a3.x, a1.x*a3.x - a1.y*a3.y*a2.x, a2.y*a3.y]]

------------------------------------------------------------
-- Lighting
------------------------------------------------------------

def diffuse(n: vec3f32, l: vec3f32, p: f32) -> f32 =
  (dot(n, l) * 0.4 + 0.6) ** p

def specular(n: vec3f32, l: vec3f32, e: vec3f32, s: f32) -> f32 =
  let nrm = (s + 8.0) / (PI * 8.0) in
  let refl = reflect(e, n) in
  (f32.max(dot(refl, l), 0.0)) ** s * nrm

------------------------------------------------------------
-- Sky
------------------------------------------------------------

def getSkyColor(e: vec3f32) -> vec3f32 =
  let ey = (f32.max(e.y, 0.0) * 0.8 + 0.2) * 0.8 in
  let r = (1.0 - ey) ** 2.0 in
  let g = 1.0 - ey in
  let b = 0.6 + (1.0 - ey) * 0.4 in
  @[r * 1.1, g * 1.1, b * 1.1]

------------------------------------------------------------
-- Sea
------------------------------------------------------------

def sea_octave(uv: vec2f32, choppy: f32) -> f32 =
  let uv2 = @[uv.x + noise(uv), uv.y + noise(uv)] in
  let wv = @[1.0 - f32.abs(f32.sin(uv2.x)), 1.0 - f32.abs(f32.sin(uv2.y))] in
  let swv = @[f32.abs(f32.cos(uv2.x)), f32.abs(f32.cos(uv2.y))] in
  let wv2 = @[mix(wv.x, swv.x, wv.x), mix(wv.y, swv.y, wv.y)] in
  (1.0 - (wv2.x * wv2.y) ** 0.65) ** choppy

-- Height map function for geometry (fewer iterations)
def heightMap(p: vec3f32, time: f32) -> f32 =
  let sea_t = sea_time(time) in
  let uv_init = @[p.x * 0.75, p.z] in
  let (_, _, h, _, _, _) = loop (i, uv, h, freq, amp, choppy) = (0, uv_init, 0.0, SEA_FREQ, SEA_HEIGHT, SEA_CHOPPY) while i < ITER_GEOMETRY do
    let d1 = sea_octave(@[(uv.x + sea_t) * freq, (uv.y + sea_t) * freq], choppy) in
    let d2 = sea_octave(@[(uv.x - sea_t) * freq, (uv.y - sea_t) * freq], choppy) in
    let h2 = h + (d1 + d2) * amp in
    let uv2 = mul(uv, octave_m) in
    (i + 1, uv2, h2, freq * 1.9, amp * 0.22, mix(choppy, 1.0, 0.2))
  in p.y - h

-- Map function for detailed normals (more iterations)
def map_detailed(p: vec3f32, time: f32) -> f32 =
  let sea_t = sea_time(time) in
  let uv_init = @[p.x * 0.75, p.z] in
  let (_, _, h, _, _, _) = loop (i, uv, h, freq, amp, choppy) = (0, uv_init, 0.0, SEA_FREQ, SEA_HEIGHT, SEA_CHOPPY) while i < ITER_FRAGMENT do
    let d1 = sea_octave(@[(uv.x + sea_t) * freq, (uv.y + sea_t) * freq], choppy) in
    let d2 = sea_octave(@[(uv.x - sea_t) * freq, (uv.y - sea_t) * freq], choppy) in
    let h2 = h + (d1 + d2) * amp in
    let uv2 = mul(uv, octave_m) in
    (i + 1, uv2, h2, freq * 1.9, amp * 0.22, mix(choppy, 1.0, 0.2))
  in p.y - h

def getSeaColor(p: vec3f32, n: vec3f32, l: vec3f32, eye: vec3f32, dist: vec3f32) -> vec3f32 =
  let fresnel_raw = clamp(1.0 - dot(n, @[0.0 - eye.x, 0.0 - eye.y, 0.0 - eye.z]), 0.0, 1.0) in
  let fresnel = f32.min(fresnel_raw * fresnel_raw * fresnel_raw, 0.5) in

  let reflected = getSkyColor(reflect(eye, n)) in
  let diff = diffuse(n, l, 80.0) in
  let refracted = @[SEA_BASE.x + diff * SEA_WATER_COLOR.x * 0.12,
                    SEA_BASE.y + diff * SEA_WATER_COLOR.y * 0.12,
                    SEA_BASE.z + diff * SEA_WATER_COLOR.z * 0.12] in

  let color = @[mix(refracted.x, reflected.x, fresnel),
                mix(refracted.y, reflected.y, fresnel),
                mix(refracted.z, reflected.z, fresnel)] in

  let atten = f32.max(1.0 - dot(dist, dist) * 0.001, 0.0) in
  let color2 = @[color.x + SEA_WATER_COLOR.x * (p.y - SEA_HEIGHT) * 0.18 * atten,
                 color.y + SEA_WATER_COLOR.y * (p.y - SEA_HEIGHT) * 0.18 * atten,
                 color.z + SEA_WATER_COLOR.z * (p.y - SEA_HEIGHT) * 0.18 * atten] in

  let spec = specular(n, l, eye, 600.0 / f32.sqrt(dot(dist, dist))) in
  @[color2.x + spec, color2.y + spec, color2.z + spec]

------------------------------------------------------------
-- Tracing
------------------------------------------------------------

def getNormal(p: vec3f32, eps: f32, time: f32) -> vec3f32 =
  let ny = map_detailed(p, time) in
  let nx = map_detailed(@[p.x + eps, p.y, p.z], time) - ny in
  let nz = map_detailed(@[p.x, p.y, p.z + eps], time) - ny in
  normalize(@[nx, eps, nz])

-- Height map tracing - returns (t, p)
def heightMapTracing(ori: vec3f32, dir: vec3f32, time: f32) -> (f32, vec3f32) =
  let tx = 1000.0 in
  let p_far = @[ori.x + dir.x * tx, ori.y + dir.y * tx, ori.z + dir.z * tx] in
  let hx = heightMap(p_far, time) in
  if hx > 0.0 then (tx, p_far)
  else
    let hm = heightMap(ori, time) in
    let (_, tm_final, tx_final, hm_final, hx_final, p_final) =
      loop (i, tm, tx, hm, hx, p) = (0, 0.0, tx, hm, hx, ori) while i < NUM_STEPS do
        let tmid = mix(tm, tx, hm / (hm - hx)) in
        let p_mid = @[ori.x + dir.x * tmid, ori.y + dir.y * tmid, ori.z + dir.z * tmid] in
        let hmid = heightMap(p_mid, time) in
        if f32.abs(hmid) < EPSILON then (NUM_STEPS, tm, tx, hm, hx, p_mid)
        else if hmid < 0.0 then (i + 1, tm, tmid, hm, hmid, p_mid)
        else (i + 1, tmid, tx, hmid, hx, p_mid)
    in
    let t_final = mix(tm_final, tx_final, hm_final / (hm_final - hx_final)) in
    let p_result = @[ori.x + dir.x * t_final, ori.y + dir.y * t_final, ori.z + dir.z * t_final] in
    (t_final, p_result)

------------------------------------------------------------
-- Main rendering
------------------------------------------------------------

def getPixel(coord: vec2f32, time: f32) -> vec3f32 =
  let uv = @[coord.x / iResolution.x, coord.y / iResolution.y] in
  let uv2 = @[uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0] in
  let uv3 = @[uv2.x * iResolution.x / iResolution.y, uv2.y] in

  -- Ray setup
  let ang = @[f32.sin(time * 3.0) * 0.1, f32.sin(time) * 0.2 + 0.3, time] in
  let ori = @[0.0, 3.5, time * 5.0] in
  let dir_base = normalize(@[uv3.x, uv3.y, -2.0]) in
  let dir_z_adj = @[dir_base.x, dir_base.y, dir_base.z + magnitude(@[uv3.x, uv3.y]) * 0.14] in
  let dir_norm = normalize(dir_z_adj) in
  let rot = fromEuler(ang) in
  let dir = mul(dir_norm, rot) in

  -- Tracing
  let (_, p) = heightMapTracing(ori, dir, time) in
  let dist = @[p.x - ori.x, p.y - ori.y, p.z - ori.z] in
  let eps_nrm = 0.1 / iResolution.x in
  let n = getNormal(p, dot(dist, dist) * eps_nrm, time) in
  let light = normalize(@[0.0, 1.0, 0.8]) in

  -- Color
  let sky = getSkyColor(dir) in
  let sea = getSeaColor(p, n, light, dir, dist) in
  let blend = (smoothstep(0.0, 0.0 - 0.02, dir.y)) ** 0.2 in
  @[mix(sky.x, sea.x, blend), mix(sky.y, sea.y, blend), mix(sky.z, sea.z, blend)]

------------------------------------------------------------
-- Fragment shader
------------------------------------------------------------

#[fragment]
def fragment_main(#[builtin(position)] fragCoord: vec4f32) -> #[location(0)] vec4f32 =
  -- Flip Y coordinate for Vulkan
  let coord = @[fragCoord.x, iResolution.y - fragCoord.y] in
  let time = iTime * 0.3 + iMouse.x * 0.01 in
  let color = getPixel(coord, time) in
  -- Gamma correction
  let gamma = 0.65 in
  @[color.x ** gamma, color.y ** gamma, color.z ** gamma, 1.0]

------------------------------------------------------------
-- Original GLSL (commented out)
------------------------------------------------------------

-- /*
--  * "Seascape" by Alexander Alekseev aka TDM - 2014
--  * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
--  * Contact: tdmaav@gmail.com
--  */
--
-- const int NUM_STEPS = 32;
-- const float PI	 	= 3.141592;
-- const float EPSILON	= 1e-3;
-- #define EPSILON_NRM (0.1 / iResolution.x)
-- //#define AA
--
-- // sea
-- const int ITER_GEOMETRY = 3;
-- const int ITER_FRAGMENT = 5;
-- const float SEA_HEIGHT = 0.6;
-- const float SEA_CHOPPY = 4.0;
-- const float SEA_SPEED = 0.8;
-- const float SEA_FREQ = 0.16;
-- const vec3 SEA_BASE = vec3(0.0,0.09,0.18);
-- const vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;
-- #define SEA_TIME (1.0 + iTime * SEA_SPEED)
-- const mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);
--
-- // math
-- mat3 fromEuler(vec3 ang) {
-- 	vec2 a1 = vec2(sin(ang.x),cos(ang.x));
--     vec2 a2 = vec2(sin(ang.y),cos(ang.y));
--     vec2 a3 = vec2(sin(ang.z),cos(ang.z));
--     mat3 m;
--     m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);
-- 	m[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);
-- 	m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);
-- 	return m;
-- }
-- float hash( vec2 p ) {
-- 	float h = dot(p,vec2(127.1,311.7));
--     return fract(sin(h)*43758.5453123);
-- }
-- float noise( in vec2 p ) {
--     vec2 i = floor( p );
--     vec2 f = fract( p );
-- 	vec2 u = f*f*(3.0-2.0*f);
--     return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ),
--                      hash( i + vec2(1.0,0.0) ), u.x),
--                 mix( hash( i + vec2(0.0,1.0) ),
--                      hash( i + vec2(1.0,1.0) ), u.x), u.y);
-- }
--
-- // lighting
-- float diffuse(vec3 n,vec3 l,float p) {
--     return pow(dot(n,l) * 0.4 + 0.6,p);
-- }
-- float specular(vec3 n,vec3 l,vec3 e,float s) {
--     float nrm = (s + 8.0) / (PI * 8.0);
--     return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;
-- }
--
-- // sky
-- vec3 getSkyColor(vec3 e) {
--     e.y = (max(e.y,0.0)*0.8+0.2)*0.8;
--     return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;
-- }
--
-- // sea
-- float sea_octave(vec2 uv, float choppy) {
--     uv += noise(uv);
--     vec2 wv = 1.0-abs(sin(uv));
--     vec2 swv = abs(cos(uv));
--     wv = mix(wv,swv,wv);
--     return pow(1.0-pow(wv.x * wv.y,0.65),choppy);
-- }
--
-- float map(vec3 p) {
--     float freq = SEA_FREQ;
--     float amp = SEA_HEIGHT;
--     float choppy = SEA_CHOPPY;
--     vec2 uv = p.xz; uv.x *= 0.75;
--
--     float d, h = 0.0;
--     for(int i = 0; i < ITER_GEOMETRY; i++) {
--     	d = sea_octave((uv+SEA_TIME)*freq,choppy);
--     	d += sea_octave((uv-SEA_TIME)*freq,choppy);
--         h += d * amp;
--     	uv *= octave_m; freq *= 1.9; amp *= 0.22;
--         choppy = mix(choppy,1.0,0.2);
--     }
--     return p.y - h;
-- }
--
-- float map_detailed(vec3 p) {
--     float freq = SEA_FREQ;
--     float amp = SEA_HEIGHT;
--     float choppy = SEA_CHOPPY;
--     vec2 uv = p.xz; uv.x *= 0.75;
--
--     float d, h = 0.0;
--     for(int i = 0; i < ITER_FRAGMENT; i++) {
--     	d = sea_octave((uv+SEA_TIME)*freq,choppy);
--     	d += sea_octave((uv-SEA_TIME)*freq,choppy);
--         h += d * amp;
--     	uv *= octave_m; freq *= 1.9; amp *= 0.22;
--         choppy = mix(choppy,1.0,0.2);
--     }
--     return p.y - h;
-- }
--
-- vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {
--     float fresnel = clamp(1.0 - dot(n, -eye), 0.0, 1.0);
--     fresnel = min(fresnel * fresnel * fresnel, 0.5);
--
--     vec3 reflected = getSkyColor(reflect(eye, n));
--     vec3 refracted = SEA_BASE + diffuse(n, l, 80.0) * SEA_WATER_COLOR * 0.12;
--
--     vec3 color = mix(refracted, reflected, fresnel);
--
--     float atten = max(1.0 - dot(dist, dist) * 0.001, 0.0);
--     color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;
--
--     color += specular(n, l, eye, 600.0 * inversesqrt(dot(dist,dist)));
--
--     return color;
-- }
--
-- // tracing
-- vec3 getNormal(vec3 p, float eps) {
--     vec3 n;
--     n.y = map_detailed(p);
--     n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;
--     n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;
--     n.y = eps;
--     return normalize(n);
-- }
--
-- float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {
--     float tm = 0.0;
--     float tx = 1000.0;
--     float hx = map(ori + dir * tx);
--     if(hx > 0.0) {
--         p = ori + dir * tx;
--         return tx;
--     }
--     float hm = map(ori);
--     for(int i = 0; i < NUM_STEPS; i++) {
--         float tmid = mix(tm, tx, hm / (hm - hx));
--         p = ori + dir * tmid;
--         float hmid = map(p);
--         if(hmid < 0.0) {
--             tx = tmid;
--             hx = hmid;
--         } else {
--             tm = tmid;
--             hm = hmid;
--         }
--         if(abs(hmid) < EPSILON) break;
--     }
--     return mix(tm, tx, hm / (hm - hx));
-- }
--
-- vec3 getPixel(in vec2 coord, float time) {
--     vec2 uv = coord / iResolution.xy;
--     uv = uv * 2.0 - 1.0;
--     uv.x *= iResolution.x / iResolution.y;
--
--     // ray
--     vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);
--     vec3 ori = vec3(0.0,3.5,time*5.0);
--     vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;
--     dir = normalize(dir) * fromEuler(ang);
--
--     // tracing
--     vec3 p;
--     heightMapTracing(ori,dir,p);
--     vec3 dist = p - ori;
--     vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);
--     vec3 light = normalize(vec3(0.0,1.0,0.8));
--
--     // color
--     return mix(
--         getSkyColor(dir),
--         getSeaColor(p,n,light,dir,dist),
--     	pow(smoothstep(0.0,-0.02,dir.y),0.2));
-- }
--
-- // main
-- void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
--     float time = iTime * 0.3 + iMouse.x*0.01;
--
-- #ifdef AA
--     vec3 color = vec3(0.0);
--     for(int i = -1; i <= 1; i++) {
--         for(int j = -1; j <= 1; j++) {
--         	vec2 uv = fragCoord+vec2(i,j)/3.0;
--     		color += getPixel(uv, time);
--         }
--     }
--     color /= 9.0;
-- #else
--     vec3 color = getPixel(fragCoord, time);
-- #endif
--
--     // post
-- 	fragColor = vec4(pow(color,vec3(0.65)), 1.0);
-- }
