module type from_prim = {
  type t
  sig i8 : i8 -> t
  sig i16 : i16 -> t
  sig i32 : i32 -> t
  sig i64 : i64 -> t
  sig u8 : u8 -> t
  sig u16 : u16 -> t
  sig u32 : u32 -> t
  sig u64 : u64 -> t
  sig f16 : f16 -> t
  sig f32 : f32 -> t
  sig f64 : f64 -> t
  sig bool : bool -> t
}
module type numeric = {
  include from_prim
  sig (+) : t -> t -> t
  sig (-) : t -> t -> t
  sig (*) : t -> t -> t
  sig (/) : t -> t -> t
  sig (%) : t -> t -> t
  sig (**) : t -> t -> t
  sig (==) : t -> t -> bool
  sig (<) : t -> t -> bool
  sig (>) : t -> t -> bool
  sig (<=) : t -> t -> bool
  sig (>=) : t -> t -> bool
  sig (!=) : t -> t -> bool
  sig neg : t -> t
  sig max : t -> t -> t
  sig min : t -> t -> t
  sig abs : t -> t
  sig sign : t -> t
  sig highest : t
  sig lowest : t
  sig sum<[n]> : [n]t -> t
  sig product<[n]> : [n]t -> t
  sig maximum<[n]> : [n]t -> t
  sig minimum<[n]> : [n]t -> t
}
module type integral = {
  include numeric
  sig (//) : t -> t -> t
  sig (%%) : t -> t -> t
  sig (&) : t -> t -> t
  sig (|) : t -> t -> t
  sig (^) : t -> t -> t
  sig not : t -> t
  sig (<<) : t -> t -> t
  sig (>>) : t -> t -> t
  sig (>>>) : t -> t -> t
  sig num_bits : i32
  sig get_bit : i32 -> t -> i32
  sig set_bit : i32 -> t -> i32 -> t
  sig popc : t -> i32
  sig mul_hi : (x: t) -> (y: t) -> t
  sig mad_hi : (a: t) -> (b: t) -> (c: t) -> t
  sig clz : t -> i32
  sig ctz : t -> i32
}
module type real = {
  include numeric
  sig recip : t -> t
  sig from_fraction : i64 -> i64 -> t
  sig sqrt : t -> t
  sig rsqrt : t -> t
  sig cbrt : t -> t
  sig exp : t -> t
  sig sin : t -> t
  sig cos : t -> t
  sig tan : t -> t
  sig asin : t -> t
  sig acos : t -> t
  sig atan : t -> t
  sig sinh : t -> t
  sig cosh : t -> t
  sig tanh : t -> t
  sig asinh : t -> t
  sig acosh : t -> t
  sig atanh : t -> t
  sig atan2 : t -> t -> t
  sig lerp : t -> t -> t -> t
  sig log : t -> t
  sig log2 : t -> t
  sig log10 : t -> t
  sig log1p : t -> t
  sig ceil : t -> t
  sig floor : t -> t
  sig trunc : t -> t
  sig round : t -> t
  sig mad : (a: t) -> (b: t) -> (c: t) -> t
  sig fma : (a: t) -> (b: t) -> (c: t) -> t
  sig isinf : t -> bool
  sig isnan : t -> bool
  sig inf : t
  sig nan : t
  sig pi : t
  sig e : t
}
module type float = {
  include real
  type int_t
  sig from_bits : int_t -> t
  sig to_bits : t -> int_t
  sig num_bits : i32
  sig epsilon : t
  sig ldexp : t -> i32 -> t
  sig copysign : (x: t) -> (y: t) -> t
}
module bool : from_prim with t = bool
module i8 : (integral with t = i8)
module i16 : (integral with t = i16)
module i32 : (integral with t = i32)
module i64 : (integral with t = i64)
module u8 : (integral with t = u8)
module u16 : (integral with t = u16)
module u32 : (integral with t = u32)
module u64 : (integral with t = u64)
module f64 : (float with t = f64 with int_t = u64)
module f32 : (float with t = f32 with int_t = u32) = {
  type t = f32
  type int_t = u32

  def i8(x: i8) t = _w_intrinsic_f32_from_i8(x)
  def i16(x: i16) t = _w_intrinsic_f32_from_i16(x)
  def i32(x: i32) t = _w_intrinsic_f32_from_i32(x)
  def i64(x: i64) t = _w_intrinsic_f32_from_i64(x)
  def u8(x: u8) t = _w_intrinsic_f32_from_u8(x)
  def u16(x: u16) t = _w_intrinsic_f32_from_u16(x)
  def u32(x: u32) t = _w_intrinsic_f32_from_u32(x)
  def u64(x: u64) t = _w_intrinsic_f32_from_u64(x)
  def f16(x: f16) t = _w_intrinsic_f32_from_f16(x)
  def f32(x: f32) t = x
  def f64(x: f64) t = _w_intrinsic_f32_from_f64(x)
  def bool(x: bool) t = if x then 1.0f32 else 0.0f32

  def neg(x: t) t = 0.0f32 - x
  def highest: t = 1.0f32 / 0.0f32
  def lowest: t = (0.0f32 - 1.0f32) / 0.0f32

  def recip(x: t) t = 1.0f32 / x
  def from_fraction(x: i64, y: i64) t = _w_intrinsic_f32_from_i64(x) / _w_intrinsic_f32_from_i64(y)

  def cbrt(x: t) t = x ** (1.0f32 / 3.0f32)
  def log10(x: t) t = f32.log(x) / f32.log(10.0f32)
  def log1p(x: t) t = f32.log((1.0f32 + x))

  def pi: t = 3.14159265358979323846f32

  def mad(a: t, b: t, c: t) t = a * b + c

  def inf: t = 1.0f32 / 0.0f32
  def nan: t = 0.0f32 / 0.0f32
  def e: t = 2.71828182845904523536f32

  def from_bits(x: int_t) t = _w_intrinsic_f32_from_bits(x)
  def to_bits(x: t) int_t = _w_intrinsic_f32_to_bits(x)
  def num_bits: i32 = 32

  def epsilon: t = 1.1920929e-7f32
  def copysign(x: t, y: t) t = if y < 0.0f32 then (0.0f32 - f32.abs(x)) else f32.abs(x)
}
module f16 : (float with t = f16 with int_t = u16)
