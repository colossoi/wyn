module type from_prim = {
type t
sig i8	: 	i8 -> t
sig i16	: 	i16 -> t
sig i32	: 	i32 -> t
sig i64	: 	i64 -> t
sig u8	: 	u8 -> t
sig u16	: 	u16 -> t
sig u32	: 	u32 -> t
sig u64	: 	u64 -> t
sig f16	: 	f16 -> t
sig f32	: 	f32 -> t
sig f64	: 	f64 -> t
sig bool	: 	bool -> t
}
module type numeric = {
include from_prim
sig (+)	: 	t -> t -> t
sig (-)	: 	t -> t -> t
sig (*)	: 	t -> t -> t
sig (/)	: 	t -> t -> t
sig (%)	: 	t -> t -> t
sig (**)	: 	t -> t -> t
sig (==)	: 	t -> t -> bool
sig (<)	: 	t -> t -> bool
sig (>)	: 	t -> t -> bool
sig (<=)	: 	t -> t -> bool
sig (>=)	: 	t -> t -> bool
sig (!=)	: 	t -> t -> bool
sig neg	: 	t -> t
sig max	: 	t -> t -> t
sig min	: 	t -> t -> t
sig abs	: 	t -> t
sig sgn	: 	t -> t
sig highest	: 	t
sig lowest	: 	t
sig sum<[n]>: 	[n]t -> t
sig product<[n]>: 	[n]t -> t
sig maximum<[n]>: 	[n]t -> t
sig minimum<[n]>: 	[n]t -> t
}
module type integral = {
include numeric
sig (//)	: 	t -> t -> t
sig (%%)	: 	t -> t -> t
sig (&)	: 	t -> t -> t
sig (|)	: 	t -> t -> t
sig (^)	: 	t -> t -> t
sig not	: 	t -> t
sig (<<)	: 	t -> t -> t
sig (>>)	: 	t -> t -> t
sig (>>>)	: 	t -> t -> t
sig num_bits	: 	i32
sig get_bit	: 	i32 -> t -> i32
sig set_bit	: 	i32 -> t -> i32 -> t
sig popc	: 	t -> i32
sig mul_hi	: 	(x: t) -> (y: t) -> t
sig mad_hi	: 	(a: t) -> (b: t) -> (c: t) -> t
sig clz	: 	t -> i32
sig ctz	: 	t -> i32
}
module type real = {
include numeric
sig recip	: 	t -> t
sig from_fraction	: 	i64 -> i64 -> t
sig sqrt	: 	t -> t
sig rsqrt	: 	t -> t
sig cbrt	: 	t -> t
sig exp	: 	t -> t
sig sin	: 	t -> t
sig cos	: 	t -> t
sig tan	: 	t -> t
sig sinpi	: 	t -> t
sig cospi	: 	t -> t
sig tanpi	: 	t -> t
sig asin	: 	t -> t
sig acos	: 	t -> t
sig atan	: 	t -> t
sig asinpi	: 	t -> t
sig acospi	: 	t -> t
sig atanpi	: 	t -> t
sig sinh	: 	t -> t
sig cosh	: 	t -> t
sig tanh	: 	t -> t
sig asinh	: 	t -> t
sig acosh	: 	t -> t
sig atanh	: 	t -> t
sig atan2	: 	t -> t -> t
sig atan2pi	: 	t -> t -> t
sig hypot	: 	t -> t -> t
sig gamma	: 	t -> t
sig lgamma	: 	t -> t
sig erf	: 	t -> t
sig erfc	: 	t -> t
sig lerp	: 	t -> t -> t -> t
sig log	: 	t -> t
sig log2	: 	t -> t
sig log10	: 	t -> t
sig log1p	: 	t -> t
sig ceil	: 	t -> t
sig floor	: 	t -> t
sig trunc	: 	t -> t
sig round	: 	t -> t
sig mad	: 	(a: t) -> (b: t) -> (c: t) -> t
sig fma	: 	(a: t) -> (b: t) -> (c: t) -> t
sig isinf	: 	t -> bool
sig isnan	: 	t -> bool
sig inf	: 	t
sig nan	: 	t
sig pi	: 	t
sig e	: 	t
}
module type float = {
include real
type int_t
sig from_bits	: 	int_t -> t
sig to_bits	: 	t -> int_t
sig num_bits	: 	i32
sig epsilon	: 	t
sig nextafter	: 	(x: t) -> (y: t) -> t
sig ldexp	: 	t -> i32 -> t
sig copysign	: 	(x: t) -> (y: t) -> t
}
module bool	: 	from_prim with t = bool
module i8	: 	(integral with t = i8)
module i16	: 	(integral with t = i16)
module i32	: 	(integral with t = i32)
module i64	: 	(integral with t = i64)
module u8	: 	(integral with t = u8)
module u16	: 	(integral with t = u16)
module u32	: 	(integral with t = u32)
module u64	: 	(integral with t = u64)
module f64	: 	(float with t = f64 with int_t = u64)
module f32	: 	(float with t = f32 with int_t = u32) = {
  type t = f32
  type int_t = u32

  def i8(x: i8) -> t = __builtin_f32_from_i8(x)
  def i16(x: i16) -> t = __builtin_f32_from_i16(x)
  def i32(x: i32) -> t = __builtin_f32_from_i32(x)
  def i64(x: i64) -> t = __builtin_f32_from_i64(x)
  def u8(x: u8) -> t = __builtin_f32_from_u8(x)
  def u16(x: u16) -> t = __builtin_f32_from_u16(x)
  def u32(x: u32) -> t = __builtin_f32_from_u32(x)
  def u64(x: u64) -> t = __builtin_f32_from_u64(x)
  def f16(x: f16) -> t = __builtin_f32_from_f16(x)
  def f32(x: f32) -> t = x
  def f64(x: f64) -> t = __builtin_f32_from_f64(x)
  def bool(x: bool) -> t = if x then 1.0f32 else 0.0f32

  -- Operators (registered in impl_source.rs)
  sig (+) : t -> t -> t
  sig (-) : t -> t -> t
  sig (*) : t -> t -> t
  sig (/) : t -> t -> t
  sig (%) : t -> t -> t
  sig (**) : t -> t -> t
  sig (==) : t -> t -> bool
  sig (!=) : t -> t -> bool
  sig (<) : t -> t -> bool
  sig (>) : t -> t -> bool
  sig (<=) : t -> t -> bool
  sig (>=) : t -> t -> bool

  def neg(x: t) -> t = 0.0f32 - x
  sig max : t -> t -> t
  sig min : t -> t -> t
  sig abs : t -> t
  def sgn(x: t) -> t = if f32.isnan(x) then x else if x > 0.0f32 then 1.0f32 else if x < 0.0f32 then (0.0f32 - 1.0f32) else 0.0f32

  def highest: t = 1.0f32 / 0.0f32
  def lowest: t = (0.0f32 - 1.0f32) / 0.0f32

  sig sum<[n]>: [n]t -> t
  sig product<[n]>: [n]t -> t
  sig maximum<[n]>: [n]t -> t
  sig minimum<[n]>: [n]t -> t

  def recip(x: t) -> t = 1.0f32 / x
  def from_fraction(x: i64, y: i64) -> t = __builtin_f32_from_i64(x) / __builtin_f32_from_i64(y)

  sig sqrt : t -> t
  sig rsqrt : t -> t
  def cbrt(x: t) -> t = x ** (1.0f32 / 3.0f32)

  sig exp : t -> t
  sig log : t -> t
  sig log2 : t -> t
  def log10(x: t) -> t = f32.log(x) / f32.log(10.0f32)
  def log1p(x: t) -> t = f32.log((1.0f32 + x))

  sig sin : t -> t
  sig cos : t -> t
  sig tan : t -> t
  sig asin : t -> t
  sig acos : t -> t
  sig atan : t -> t

  def pi: t = 3.14159265358979323846f32
  def sinpi(x: t) -> t = f32.sin((pi * x))
  def cospi(x: t) -> t = f32.cos((pi * x))
  def tanpi(x: t) -> t = f32.tan((pi * x))
  def asinpi(x: t) -> t = f32.asin(x) / pi
  def acospi(x: t) -> t = f32.acos(x) / pi
  def atanpi(x: t) -> t = f32.atan(x) / pi

  sig sinh : t -> t
  sig cosh : t -> t
  sig tanh : t -> t
  sig asinh : t -> t
  sig acosh : t -> t
  sig atanh : t -> t

  sig atan2 : t -> t -> t
  def atan2pi(x: t, y: t) -> t = f32.atan2(x, y) / pi
  def hypot(x: t, y: t) -> t = f32.sqrt((x * x + y * y))

  def gamma(x: t) -> t = x
  def lgamma(x: t) -> t = x
  def erf(x: t) -> t = x
  def erfc(x: t) -> t = x

  sig lerp : t -> t -> t -> t
  def mad(a: t, b: t, c: t) -> t = a * b + c
  sig fma : t -> t -> t -> t

  sig ceil : t -> t
  sig floor : t -> t
  sig trunc : t -> t
  sig round : t -> t

  sig isinf : t -> bool
  sig isnan : t -> bool
  def inf: t = 1.0f32 / 0.0f32
  def nan: t = 0.0f32 / 0.0f32
  def e: t = 2.71828182845904523536f32

  def from_bits(x: int_t) -> t = __builtin_f32_from_bits(x)
  def to_bits(x: t) -> int_t = __builtin_f32_to_bits(x)
  def num_bits: i32 = 32
  def get_bit(bit: i32, x: t) -> i32 = 0i32
  def set_bit(bit: i32, x: t, b: i32) -> t = x

  def epsilon: t = 1.1920929e-7f32
  def nextafter(x: t, y: t) -> t = x
  def ldexp(x: t, n: i32) -> t = x
  def copysign(x: t, y: t) -> t = if y < 0.0f32 then (0.0f32 - f32.abs(x)) else f32.abs(x)
}
module f16	: 	(float with t = f16 with int_t = u16)
