module type from_prim = {
  type t
  sig i8 : i8 -> t
  sig i16 : i16 -> t
  sig i32 : i32 -> t
  sig i64 : i64 -> t
  sig u8 : u8 -> t
  sig u16 : u16 -> t
  sig u32 : u32 -> t
  sig u64 : u64 -> t
  sig f16 : f16 -> t
  sig f32 : f32 -> t
  sig f64 : f64 -> t
  sig bool : bool -> t
}
module type numeric = {
  include from_prim
  sig (+) : t -> t -> t
  sig (-) : t -> t -> t
  sig (*) : t -> t -> t
  sig (/) : t -> t -> t
  sig (%) : t -> t -> t
  sig (**) : t -> t -> t
  sig (==) : t -> t -> bool
  sig (<) : t -> t -> bool
  sig (>) : t -> t -> bool
  sig (<=) : t -> t -> bool
  sig (>=) : t -> t -> bool
  sig (!=) : t -> t -> bool
  sig neg : t -> t
  sig max : t -> t -> t
  sig min : t -> t -> t
  sig abs : t -> t
  sig sgn : t -> t
  sig highest : t
  sig lowest : t
  sig sum<[n]> : [n]t -> t
  sig product<[n]> : [n]t -> t
  sig maximum<[n]> : [n]t -> t
  sig minimum<[n]> : [n]t -> t
}
module type integral = {
  include numeric
  sig (//) : t -> t -> t
  sig (%%) : t -> t -> t
  sig (&) : t -> t -> t
  sig (|) : t -> t -> t
  sig (^) : t -> t -> t
  sig not : t -> t
  sig (<<) : t -> t -> t
  sig (>>) : t -> t -> t
  sig (>>>) : t -> t -> t
  sig num_bits : i32
  sig get_bit : i32 -> t -> i32
  sig set_bit : i32 -> t -> i32 -> t
  sig popc : t -> i32
  sig mul_hi : (x: t) -> (y: t) -> t
  sig mad_hi : (a: t) -> (b: t) -> (c: t) -> t
  sig clz : t -> i32
  sig ctz : t -> i32
}
module type real = {
  include numeric
  sig recip : t -> t
  sig from_fraction : i64 -> i64 -> t
  sig sqrt : t -> t
  sig rsqrt : t -> t
  sig cbrt : t -> t
  sig exp : t -> t
  sig sin : t -> t
  sig cos : t -> t
  sig tan : t -> t
  sig sinpi : t -> t
  sig cospi : t -> t
  sig tanpi : t -> t
  sig asin : t -> t
  sig acos : t -> t
  sig atan : t -> t
  sig asinpi : t -> t
  sig acospi : t -> t
  sig atanpi : t -> t
  sig sinh : t -> t
  sig cosh : t -> t
  sig tanh : t -> t
  sig asinh : t -> t
  sig acosh : t -> t
  sig atanh : t -> t
  sig atan2 : t -> t -> t
  sig atan2pi : t -> t -> t
  sig hypot : t -> t -> t
  sig gamma : t -> t
  sig lgamma : t -> t
  sig erf : t -> t
  sig erfc : t -> t
  sig lerp : t -> t -> t -> t
  sig log : t -> t
  sig log2 : t -> t
  sig log10 : t -> t
  sig log1p : t -> t
  sig ceil : t -> t
  sig floor : t -> t
  sig trunc : t -> t
  sig round : t -> t
  sig mad : (a: t) -> (b: t) -> (c: t) -> t
  sig fma : (a: t) -> (b: t) -> (c: t) -> t
  sig isinf : t -> bool
  sig isnan : t -> bool
  sig inf : t
  sig nan : t
  sig pi : t
  sig e : t
}
module type float = {
  include real
  type int_t
  sig from_bits : int_t -> t
  sig to_bits : t -> int_t
  sig num_bits : i32
  sig epsilon : t
  sig ldexp : t -> i32 -> t
  sig copysign : (x: t) -> (y: t) -> t
}
module bool : from_prim with t = bool
module i8 : (integral with t = i8)
module i16 : (integral with t = i16)
module i32 : (integral with t = i32)
module i64 : (integral with t = i64)
module u8 : (integral with t = u8)
module u16 : (integral with t = u16)
module u32 : (integral with t = u32)
module u64 : (integral with t = u64)
module f64 : (float with t = f64 with int_t = u64)
module f32 : (float with t = f32 with int_t = u32) = {
  type t = f32
  type int_t = u32

  def i8(x: i8) -> t = _w_intrinsic_f32_from_i8(x)
  def i16(x: i16) -> t = _w_intrinsic_f32_from_i16(x)
  def i32(x: i32) -> t = _w_intrinsic_f32_from_i32(x)
  def i64(x: i64) -> t = _w_intrinsic_f32_from_i64(x)
  def u8(x: u8) -> t = _w_intrinsic_f32_from_u8(x)
  def u16(x: u16) -> t = _w_intrinsic_f32_from_u16(x)
  def u32(x: u32) -> t = _w_intrinsic_f32_from_u32(x)
  def u64(x: u64) -> t = _w_intrinsic_f32_from_u64(x)
  def f16(x: f16) -> t = _w_intrinsic_f32_from_f16(x)
  def f32(x: f32) -> t = x
  def f64(x: f64) -> t = _w_intrinsic_f32_from_f64(x)
  def bool(x: bool) -> t = if x then 1.0f32 else 0.0f32

  def neg(x: t) -> t = 0.0f32 - x
  def highest: t = 1.0f32 / 0.0f32
  def lowest: t = (0.0f32 - 1.0f32) / 0.0f32

  def recip(x: t) -> t = 1.0f32 / x
  def from_fraction(x: i64, y: i64) -> t = _w_intrinsic_f32_from_i64(x) / _w_intrinsic_f32_from_i64(y)

  def cbrt(x: t) -> t = x ** (1.0f32 / 3.0f32)
  def log10(x: t) -> t = f32.log(x) / f32.log(10.0f32)
  def log1p(x: t) -> t = f32.log((1.0f32 + x))

  def pi: t = 3.14159265358979323846f32
  def sinpi(x: t) -> t = f32.sin((pi * x))
  def cospi(x: t) -> t = f32.cos((pi * x))
  def tanpi(x: t) -> t = f32.tan((pi * x))
  def asinpi(x: t) -> t = f32.asin(x) / pi
  def acospi(x: t) -> t = f32.acos(x) / pi
  def atanpi(x: t) -> t = f32.atan(x) / pi

  def atan2pi(x: t, y: t) -> t = f32.atan2(x, y) / pi
  def hypot(x: t, y: t) -> t = f32.sqrt((x * x + y * y))

  -- Log-gamma using Stirling's approximation (good for x > 0)
  def lgamma(x: t) -> t =
    let log2pi = 1.8378770664093453f32 in
    (x - 0.5f32) * f32.log(x) - x + 0.5f32 * log2pi + 1.0f32 / (12.0f32 * x)
  def gamma(x: t) -> t = f32.exp(f32.lgamma(x))
  -- Error function using Abramowitz and Stegun approximation
  def erf(x: t) -> t =
    let a1 = 0.254829592f32 in
    let a2 = 0.0f32 - 0.284496736f32 in
    let a3 = 1.421413741f32 in
    let a4 = 0.0f32 - 1.453152027f32 in
    let a5 = 1.061405429f32 in
    let p  = 0.3275911f32 in
    let sign = if x < 0.0f32 then 0.0f32 - 1.0f32 else 1.0f32 in
    let ax = f32.abs(x) in
    let t = 1.0f32 / (1.0f32 + p * ax) in
    let y = 1.0f32 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * f32.exp(0.0f32 - ax * ax) in
    sign * y
  def erfc(x: t) -> t = 1.0f32 - f32.erf(x)

  def mad(a: t, b: t, c: t) -> t = a * b + c

  def inf: t = 1.0f32 / 0.0f32
  def nan: t = 0.0f32 / 0.0f32
  def e: t = 2.71828182845904523536f32

  def from_bits(x: int_t) -> t = _w_intrinsic_f32_from_bits(x)
  def to_bits(x: t) -> int_t = _w_intrinsic_f32_to_bits(x)
  def num_bits: i32 = 32

  def epsilon: t = 1.1920929e-7f32
  def copysign(x: t, y: t) -> t = if y < 0.0f32 then (0.0f32 - f32.abs(x)) else f32.abs(x)
}
module f16 : (float with t = f16 with int_t = u16)
