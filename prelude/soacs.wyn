-- Second-Order Array Combinators (SOACs)
-- Based on Futhark's prelude/soacs module
--
-- Builtins: map (desugared to map1), map1-map5, reduce, scan, filter, scatter, length, replicate

------------------------------------------------------------
-- Zipping and unzipping
------------------------------------------------------------

-- Combine two arrays into an array of pairs
def zip<[n], A, B>(xs: [n]A, ys: [n]B) -> [n](A, B) =
  map2((|x: A, y: B| (x, y)), xs, ys)

-- Split an array of pairs into two arrays
def unzip<[n], A, B>(xys: [n](A, B)) -> ([n]A, [n]B) =
  (map((|xy: (A, B)| let (a, _) = xy in a), xys),
   map((|xy: (A, B)| let (_, b) = xy in b), xys))

-- 3-way zip
def zip3<[n], A, B, C>(xs: [n]A, ys: [n]B, zs: [n]C) -> [n](A, B, C) =
  map3((|x: A, y: B, z: C| (x, y, z)), xs, ys, zs)

-- 4-way zip
def zip4<[n], A, B, C, D>(as: [n]A, bs: [n]B, cs: [n]C, ds: [n]D) -> [n](A, B, C, D) =
  map4((|a: A, b: B, c: C, d: D| (a, b, c, d)), as, bs, cs, ds)

-- 5-way zip
def zip5<[n], A, B, C, D, E>(as: [n]A, bs: [n]B, cs: [n]C, ds: [n]D, es: [n]E) -> [n](A, B, C, D, E) =
  map5((|a: A, b: B, c: C, d: D, e: E| (a, b, c, d, e)), as, bs, cs, ds, es)

------------------------------------------------------------
-- Boolean aggregation
------------------------------------------------------------

-- Test if predicate holds for all elements
def all<[n], A>(p: A -> bool, xs: [n]A) -> bool =
  reduce((|a: bool, b: bool| a && b), true, map(p, xs))

-- Test if predicate holds for any element
def any<[n], A>(p: A -> bool, xs: [n]A) -> bool =
  reduce((|a: bool, b: bool| a || b), false, map(p, xs))

------------------------------------------------------------
-- Array generation
------------------------------------------------------------

-- Generate array by applying function to each index
-- tabulate size f = [f 0, f 1, ..., f (size-1)]
def tabulate<[n], A>(size: i32, f: i32 -> A) -> [n]A =
  map(f, 0..<size)

-- (replicate is a builtin)

------------------------------------------------------------
-- Array slicing
------------------------------------------------------------

-- TODO: Requires slice syntax support in type checker
-- First k elements of array
-- def take<[n], [k], A>(k: i32, arr: [n]A) -> [k]A =
--   arr[0:k]

-- TODO: Requires slice syntax support in type checker
-- Drop first k elements of array
-- def drop<[n], [k], A>(k: i32, arr: [n]A) -> [k]A =
--   arr[k:length(arr)]

------------------------------------------------------------
-- Array transformations
------------------------------------------------------------

-- Reverse an array
def reverse<[n], A>(arr: [n]A) -> [n]A =
  map((|i: i32| arr[length(arr) - 1 - i]), 0..<length(arr))

-- Rotate array left by k positions
def rotate<[n], A>(k: i32, arr: [n]A) -> [n]A =
  map((|i: i32| arr[(i + k) % length(arr)]), 0..<length(arr))

-- TODO: Requires size arithmetic in types [n * m]
-- Flatten a 2D array into 1D
-- def flatten<[n], [m], A>(arr: [n][m]A) -> [n * m]A =
--   map((|i: i32| arr[i / m][i % m]), 0..<(n * m))

------------------------------------------------------------
-- Scatter variants
------------------------------------------------------------

-- TODO: Requires existential size parameter for replicate result
-- Spread: scatter values into a default array
-- spread k default indices values = scatter (replicate k default) indices values
-- def spread<[n], [k], A>(size: i32, default: A, indices: [n]i32, values: [n]A) -> [k]A =
--   scatter(replicate(size, default), indices, values)

------------------------------------------------------------
-- Reduce variants
------------------------------------------------------------

-- Commutative reduce (same as reduce, but documents commutativity)
def reduce_comm<[n], A>(op: A -> A -> A, ne: A, arr: [n]A) -> A =
  reduce(op, ne, arr)

------------------------------------------------------------
-- Partitioning
------------------------------------------------------------

-- TODO: Requires existential types in return position
-- Partition array by predicate into (matching, non-matching)
-- Note: This creates two filtered copies
-- def partition<[n], A>(p: A -> bool, arr: [n]A) -> (exists k. [k]A, exists m. [m]A) =
--   (filter(p, arr), filter((|x: A| !(p(x))), arr))

------------------------------------------------------------
-- Index operations
------------------------------------------------------------

-- TODO: Requires existential types in return position
-- Find indices where predicate holds
-- def indices<[n], A>(p: A -> bool, arr: [n]A) -> (exists k. [k]i32) =
--   filter((|i: i32| p(arr[i])), 0..<length(arr))

-- TODO: Requires length on existential arrays
-- Find first index where predicate holds, or -1
-- def find_index<[n], A>(p: A -> bool, arr: [n]A) -> i32 =
--   let matches = indices(p, arr) in
--   if length(matches) > 0 then matches[0] else (0 - 1)
