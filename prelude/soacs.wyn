-- Second-Order Array Combinators (SOACs)
-- Based on Futhark's prelude/soacs module
--
-- Fundamental SOACs (map, reduce, scan, filter, scatter, zip, length, replicate, reduce_by_index)
-- are true builtins registered in the type checker. This file provides derived combinators.

------------------------------------------------------------
-- Zipping and unzipping
------------------------------------------------------------

-- Split an array of pairs into two arrays
def unzip<[n], A, B>(xys: [n](A, B)) ([n]A, [n]B) =
  (map(|(a, _): (A, B)| a, xys),
   map(|(_, b): (A, B)| b, xys))

-- 3-way zip (produces flat tuples)
def zip3<[n], A, B, C>(xs: [n]A, ys: [n]B, zs: [n]C) [n](A, B, C) =
  map(|((a, b), c): ((A, B), C)| (a, b, c), zip(zip(xs, ys), zs))

-- 4-way zip (produces flat tuples)
def zip4<[n], A, B, C, D>(as: [n]A, bs: [n]B, cs: [n]C, ds: [n]D) [n](A, B, C, D) =
  map(|(((a, b), c), d): (((A, B), C), D)| (a, b, c, d), zip(zip(zip(as, bs), cs), ds))

-- 5-way zip (produces flat tuples)
def zip5<[n], A, B, C, D, E>(as: [n]A, bs: [n]B, cs: [n]C, ds: [n]D, es: [n]E) [n](A, B, C, D, E) =
  map(|((((a, b), c), d), e): ((((A, B), C), D), E)| (a, b, c, d, e), zip(zip(zip(zip(as, bs), cs), ds), es))

------------------------------------------------------------
-- Multi-argument map functions (built from map + zip)
------------------------------------------------------------

-- Map over two arrays in parallel
def map2<[n], A, B, C>(f: (A, B) -> C, xs: [n]A, ys: [n]B) [n]C =
  map(f, zip(xs, ys))

-- Map over three arrays in parallel
def map3<[n], A, B, C, D>(f: (A, B, C) -> D, xs: [n]A, ys: [n]B, zs: [n]C) [n]D =
  map(f, zip3(xs, ys, zs))

-- Map over four arrays in parallel
def map4<[n], A, B, C, D, E>(f: (A, B, C, D) -> E, as: [n]A, bs: [n]B, cs: [n]C, ds: [n]D) [n]E =
  map(f, zip4(as, bs, cs, ds))

-- Map over five arrays in parallel
def map5<[n], A, B, C, D, E, F>(f: (A, B, C, D, E) -> F, as: [n]A, bs: [n]B, cs: [n]C, ds: [n]D, es: [n]E) [n]F =
  map(f, zip5(as, bs, cs, ds, es))

------------------------------------------------------------
-- Boolean aggregation
------------------------------------------------------------

-- Test if predicate holds for all elements
def all<[n], A>(p: A -> bool, xs: [n]A) bool =
  reduce(|a, b| a && b, true, map(p, xs))

-- Test if predicate holds for any element
def any<[n], A>(p: A -> bool, xs: [n]A) bool =
  reduce(|a, b| a || b, false, map(p, xs))

------------------------------------------------------------
-- Array generation
------------------------------------------------------------

-- Generate array of sequential integers [0, 1, 2, ..., n-1]
-- Fundamental for distributing work across parallel threads.
def iota<[n]>(size: i32) [n]i32 = 0..<size

-- Generate array by applying function to each index
-- tabulate size f = [f 0, f 1, ..., f (size-1)]
def tabulate<[n], A>(size: i32, f: i32 -> A) [n]A =
  map(f, iota(size))

------------------------------------------------------------
-- Array transformations
------------------------------------------------------------

-- Reverse an array
def reverse<[n], A>(arr: [n]A) [n]A =
  let len = length(arr)
  in map(|i| arr[len - 1 - i], iota(len))

-- Rotate array left by k positions
def rotate<[n], A>(k: i32, arr: [n]A) [n]A =
  let len = length(arr)
  in map(|i| arr[(i + k) % len], iota(len))

------------------------------------------------------------
-- Reduce variants
------------------------------------------------------------

-- Commutative reduce (same as reduce, but documents commutativity)
def reduce_comm<[n], A>(op: A -> A -> A, ne: A, arr: [n]A) A =
  reduce(op, ne, arr)

------------------------------------------------------------
-- Partitioning
------------------------------------------------------------

-- Split array into elements satisfying predicate and those that don't
-- Returns (elements where p is true, elements where p is false)
def partition<[n], A>(p: A -> bool, xs: [n]A) =
  (filter(p, xs), filter(|x| !p(x), xs))

------------------------------------------------------------
-- Spread
------------------------------------------------------------

-- Place values at indices in array filled with default value
def spread<[n], [m], A>(size: i32, default: A, indices: [m]i32, values: [m]A) [n]A =
  scatter(replicate(size, default), indices, values)

------------------------------------------------------------
-- Histogram
------------------------------------------------------------

-- Histogram (alias for reduce_by_index builtin)
def hist<[n], [m], A>(dest: [n]A, op: A -> A -> A, ne: A, indices: [m]i32, values: [m]A) [n]A =
  reduce_by_index(dest, op, ne, indices, values)
